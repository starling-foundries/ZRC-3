scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
import BoolUtils ListUtils
library MetaFungibleToken

let one_msg = 
  fun (msg : Message) => 
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

(* Error events *)
type Error =
  | CodeNotAuthorised
  | CodeNotFound
  | CodeBadRequest
  | CodeTokenExists
  | CodeNonceError
  | CodeUnexpectedError

let makeError =
  fun (result : Error) =>
    let result_code = 
      match result with
      | CodeNotAuthorised    => Int32 -1
      | CodeNotFound         => Int32 -2
      | CodeBadRequest       => Int32 -3
      | CodeTokenExists      => Int32 -4
      | CodeNonceError       => Int32 -5
      | CodeUnexpectedError  => Int32 -6
      end
    in
    { _eventname : "Error"; code : result_code }


let le_int =
  fun (a : Uint128) => fun (b : Uint128) =>
    let x = builtin lt a b in
    match x with
    | True => True
    | False =>
      let y = builtin eq a b in
      match y with
      | True => True
      | False => False
      end
    end
    
(* A util function to test equality *)
let f_eq =
  fun (a : ByStr20) =>
  fun (b : ByStr20) =>
    builtin eq a b

(* a utility function for checking that a message sender key, hash and signature matchup *)
let valid_check_hash = 
    fun(key: ByStr33) =>
    fun(hash: ByStr) =>
    fun(sig: ByStr64) =>
        builtin schnorr_verify key hash sig

(* Instantiate a type function to test membership in a list *)
let isDefaultTeller = @list_mem ByStr20
    

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract MetaFungibleToken
(contractOwner: ByStr20,
  name : String,
  symbol: String,
  decimals: Uint32,
  default_tellers : List ByStr20
)

(* Mutable fields *)

field total_tokens : Uint128 = Uint128 0

field revokedDefaultTellers : Map ByStr20 (Map ByStr20 Bool) = Emp ByStr20 (Map ByStr20 Bool)

field balancesMap: Map ByStr20 Uint128 
  = Emp ByStr20 Uint128

field tellersMap: Map ByStr20 (Map ByStr20 Bool) 
  = Emp ByStr20 (Map ByStr20 Bool)

field allowancesMap: Map ByStr20 (Map ByStr20 Uint128) 
  = Emp ByStr20 (Map ByStr20 Uint128)

field accountNonce: Map ByStr20 Uint128 = Emp ByStr20 Uint128

(* Procedures *)

(* Emit Errors *)
procedure MakeError(err : Error)
  e = makeError err;
  event e
end

(* Mint Tokens *)
procedure ProcedureMint(to: ByStr20, amount: Uint128) 
  optionBal <- balancesMap[to];
  balance = 
    match optionBal with
    | Some bal => bal
    | None => Uint128 0
  end;
  newCount = builtin add amount balance;
  balancesMap[to] := newCount;
  e = {_eventname: "ProcedureMintSuccess"; recipient: to; amount: amount};
  event e
end

(* Burn Tokens *)
procedure ProcedureBurn(from: ByStr20, amount: Uint128, nonce: Uint128)
  optionBal <- balancesMap[from];
    match optionBal with
    | None => 
      err = CodeUnexpectedError;
      MakeError err
    | Some userTokens =>
      can_burn = le_int amount userTokens;
      match can_burn with
      | False =>
        err = CodeUnexpectedError;
        MakeError err
      | True =>
        (*check nonce is valid*)
        old_nonce <- accountNonce[from];
        valid_nonce = le_int old_nonce nonce;
        match valid_nonce with
        | True =>
        (* subtract amount from 'from' *)
        new_user_bal = builtin sub userTokens amount;
        balancesMap[from] := new_user_bal;
        accountNonce[from] := nonce;
        e = {_eventname: "ProcedureBurnSuccess"; from: from; amount: amount};
        event e
        | False =>
        err = CodeNonceError;
        MakeError err
        end
    end
  end
end
(* Move Tokens *)
procedure ProcedureMove(from: ByStr20, to: ByStr20, amount: Uint128, nonce: Uint128)
  bal <- balancesMap[from];
  match bal with
  | Some b =>
    can_do = le_int amount b;
    match can_do with
    | True =>
      (*check nonce is valid*)
      old_nonce <- accountNonce[from];
      valid_nonce = le_int old_nonce nonce;
      match valid_nonce with
      | True =>
        (* subtract amount from _sender and add it to "to" *)
        new_sender_bal = builtin sub b amount;
        balancesMap[from] := new_sender_bal;
        accountNonce[from] := nonce;
      (* Adds amount to "to" address *)
      to_bal <- balancesMap[to];
      new_to_bal = match to_bal with
        | Some x => builtin add x amount
        | None => amount
      end;
      
      balancesMap[to] := new_to_bal;
      e = {_eventname : "ProcedureMoveSuccess"; sender : from; recipient : to; amount : amount};
      event e
      | False =>
      err = CodeNonceError;
      MakeError err
    end
    | False =>
      (* balance not sufficient. *)
      e = {_eventname : "ProcedureMoveFailure"; sender : from; recipient : to; amount : Uint128 0};
      event e
    end
  | None =>
    (* no balance record, can't transfer *)
  	e = {_eventname : "ProcedureMoveFailure"; sender : _sender; recipient : to; amount : Uint128 0};
    event e
  end
end
(* Approve Spender *)
procedure ProcedureApprove(spender: ByStr20, amount: Uint128)
  allowancesMap[_sender][spender] := amount;
  e = {_eventname : "ProcedureApproveSuccess"; sender : _sender; spender: spender; amount : amount};
  event e
end

(* Transitions *)

(* Re-authorize a default teller *)
(* @param teller: Address of the teller to be re-authorized. *)
transition reauthorizeDefaultTeller(teller : ByStr20)  
  isDefaultTeller = isDefaultTeller f_eq teller default_tellers;
  match isDefaultTeller with
  | False =>
    err = CodeNotFound;
    MakeError err
  | True  => 
    delete revokedDefaultTellers[_sender][teller];
    e = { _eventname : "ReAuthorizedDefaultTellerSuccess"; teller : teller; sender : _sender};
    event e
  end
end

(* Revoke a default teller *)
(* @param teller:  Address of the teller to be revoked. *)
transition revokeDefaultTeller(teller : ByStr20)
  isDefaultTeller =  isDefaultTeller f_eq teller default_tellers;
  match isDefaultTeller with
  | False =>
    err = CodeNotFound;
    MakeError err
  | True  => 
    verdad = True;
    revokedDefaultTellers[_sender][teller] := verdad;
    e = {_eventname : "RevokedDefaultTellerSuccess"; teller : teller; sender : _sender};
    event e
    end
end

(* @dev: Moves amount tokens from the callerâ€™s address to the recipient.   *)
(* @param from:       Address of the sender whose balance is decreased.    *)
(* @param recipient:  Address of the recipient whose balance is increased. *)
(* @param amount:     Amount of tokens to be sent.                         *)
transition Send(from: ByStr20, recipient: ByStr20, amount: Uint128)
  nonce <-accountNonce[from];
  newNonce = builtin add nonce 1;
  isSender = builtin eq _sender from;
    match isSender with
    | False =>
      err = CodeNotAuthorised;
      MakeError err
    | True =>
      ProcedureMove from recipient amount newNonce
    end
end

(* @dev: Moves amount tokens from sender to recipient via metatransaction. *)
(* @param tokenOwner: Address of the sender whose balance is decreased.    *)
(* @param recipient:  Address of the recipient whose balance is increased. *)
(* @param amount:     Amount of tokens to be sent.                         *)
(* @param pubKey:     The ByStr33 public key of the tokenOwner             *)
(* @param checkHash:  teller-supplied hash of the metatransaction check.   *)
(* @param checkSig:   Signature of checkHash - supplied by the tokenOwer.  *)
(* @param tip:        Amount of tokens tokenOwner allocated for the teller *)
(* @param nonce:      The account-specific nonce to use for transaction    *)
transition SendCheck(tokenOwner: ByStr20, recipient: ByStr20, amount: Uint128, ownerPubkey: ByStr33 checkHash:ByStr, checkSig: ByStr64, tip: Uint128, nonce: Uint128)
  someTeller <- tellersMap[tokenOwner][teller];
  isApproved = 
    match someTeller with
    | Some value => value
    | None => False
    end;
  match isApproved with
    | False =>
      err = CodeNotAuthorised;
      MakeError err
    | True =>
      (* Begin substantial additions for ZRC3 *)
      isValidCheck = valid_check_hash ownerPubkey checkHash checkSig
      match isValidCheck with
      | False => 
          err = CodeBadRequest;
          MakeError err
      | True =>
          ProcedureMove tokenOwner recipient amount nonce
    end 
   end
end

(* @dev: Burn existing tokens. Only tokenOwner.                  *)
(* @param burn_account: Address holding the tokens to be burned. *)
(* @param amount:       Number of tokens to be destroyed.        *)
transition Burn(burn_account: ByStr20, amount: Uint128)
    isSender = builtin eq _sender contractOwner;
    match isSender with
    | False =>
      err = CodeNotAuthorised;
      MakeError err
    | True =>
      ProcedureBurn burn_account amount
    end
end

(* @dev: Burn existing tokens. Only approved teller can burn a token. *)
(* @param tokenOwner: Address holding the tokens to be burned.          *)
(* @param amount:     Number of tokens to be destroyed.                 *)
transition TellerBurn(teller: ByStr20, tokenOwner: ByStr20, amount: Uint128)
  isDefaultTeller = isDefaultTeller f_eq teller default_tellers;
  isRevokedTeller <- exists revokedDefaultTellers[tokenOwner][teller];
  isAllowed = let isNotRevokedTeller = negb isRevokedTeller in andb  isNotRevokedTeller isDefaultTeller;
  match isAllowed with
    | False =>
      err = CodeNotAuthorised;
      MakeError err
    | True =>
      ProcedureBurn tokenOwner amount
   end
end

(* @dev: Mint new tokens. Only contractOwner can mint.                    *)
(* @param recipient: Address of the recipient whose balance is increased. *)
(* @param amount:   Number of tokens to be burned.                        *)
transition Mint(recipient: ByStr20, amount: Uint128)
  isOwner = builtin eq _sender contractOwner;
   match isOwner with
    | False =>
      err = CodeNotAuthorised;
      MakeError err
    | True =>
      ProcedureMint recipient amount
    end
end

(* @dev: Mint new tokens. Only approved teller can mint tokens.         *)
(* @param teller:  Address must be an teller of `to`.                 *)
(* @param recipient: Address of the recipient whose balance is increased. *)
(* @param amount:    Number of tokens to be burned.                       *)
transition TellerMint(teller: ByStr20, recipient: ByStr20, amount: Uint128)
  isDefaultTeller = isDefaultTeller f_eq teller default_tellers;
  isRevokedTeller <- exists revokedDefaultTellers[recipient][teller];
  isAllowed = let isNotRevokedTeller = negb isRevokedTeller in andb  isNotRevokedTeller isDefaultTeller;
  match isAllowed with
    | False =>
      err = CodeNotAuthorised;
      MakeError err
    | True =>
      ProcedureMint recipient amount
   end
end

(* @dev: Make an address an teller of the caller.                           *)
(* @param teller: Address to be set as teller. Cannot be calling address. *)
transition AuthorizeTeller(teller: ByStr20)
  is_sender = builtin eq teller _sender;
  match is_sender with
  | True =>
    (* Teller is calling address, return error code *)
    err = CodeNotAuthorised;
    MakeError err
  | False =>
    authorize = True;
    tellersMap[_sender][teller] := authorize;
    e = {_eventname : "AuthorizeTellerSuccess"; teller : teller};
    event e
  end
end

(* @dev: Revoke an address from being an teller of the caller. *)
(* @param teller:         Address to be unset as teller.     *)
transition RevokeTeller(teller: ByStr20)
  getTeller <- tellersMap[_sender][teller];
  match getTeller with
  | None =>
    (* Teller to be removed not found *)
    err = CodeNotFound;
    MakeError err
  | Some v =>
    delete tellersMap[_sender][teller];
    e = {_eventname : "RevokeTellerSuccess"; teller : teller};
    event e
  end
end

(* @dev: Returns true if an address is an teller of tokenHolder. *)
(* All addresses are their own teller.                           *)
(* @param teller:     Address of a potential teller.           *)
(* @param tokenHolder:  Address of a token holder.                 *)
transition IsTellerFor(teller: ByStr20, tokenHolder: ByStr20)
  getTeller <- tellersMap[tokenHolder][teller];
    match getTeller with
  | None =>
    (* Teller not found *)
    e = {_eventname : "IsTellerForSuccess"; tokenHolder: tokenHolder; teller : teller; isTeller : "False"};
    event e
  | Some v =>
    match v with
    | True =>
      e = {_eventname : "IsTellerForSuccess"; tokenHolder: tokenHolder; teller : teller;  isTeller : "True"};
      event e
    | False =>
      e = {_eventname : "IsTellerForSuccess"; tokenHolder: tokenHolder; teller : teller;  isTeller : "False"};
      event e
    end
  end
end

(* @dev: Returns the list of default tellers.         *)
(* These addresses are tellers for all token holders. *)
transition DefaultTellers()
  e = {_eventname : "DefaultTellersSuccess"; list: default_tellers };
  event e
end

(* @dev: Move a given amount of tokens from one address another.       *)
(* @param to:     Address of the recipient whose balance is increased. *)
(* @param amount: Number of tokens to be transferred.                  *)
transition Transfer(to: ByStr20, amount: Uint128)
  ProcedureMove _sender to amount
end

(* @dev: Move a given amount of tokens from one address another using the allowance mechanism. *)
(* param from:    Address of the sender whose balance is deccreased.                           *)
(* param to:      Address of the recipient whose balance is increased.                         *)
(* param amount:  Number of tokens to be transferred.                                          *)
transition TansferFrom(from: ByStr20, to: ByStr20, amount: Uint128)
  (* Check if sender is tokenOwner *)
  isOwner = builtin eq _sender from;
  match isOwner with
  | False =>
    err = CodeNotAuthorised;
    MakeError err
  | True =>
    ProcedureMove from to amount
  end
end

(* @dev: Returns the number of tokens spender is allowed to spend on behalf of owner. *)
(* param tokenHolder:  Address of a token holder.                                     *)
(* param spender:      Address to be set as a spender.                                *)
transition Allowance(tokenHolder: ByStr20, spender: ByStr20)
  optionalAllowance <- allowancesMap[tokenHolder][spender];
  match optionalAllowance with
  | None =>
    (* No Allowance is set up with spender *)
    err = CodeNotFound;
    MakeError err
  | Some v =>
    e = {_eventname : "AllowanceSuccess"; tokenHolder: tokenHolder; spender : spender;  allowance : v};
    event e
  end
end

(* @dev: Sets amount as the allowance of spender over the callerâ€™s tokens.  *)
(* param spender:      Address to be set as a spender.                      *)
(* param amount:       Number of tokens to be approved for a given spender. *)
transition Approve(spender: ByStr20, amount: Uint128)
  (* Checks if the _sender is approving himself *)
  isOwner = builtin eq _sender spender;
    match isOwner with
  | True =>
    err = CodeNotAuthorised;
    MakeError err
  | False =>
    ProcedureApprove spender amount
  end
end

(* @dev: Returns the amount of tokens in existence. *)
transition TotalSupply()
  tokens <- total_tokens;
  e = {_eventname : "TotalSupply"; caller : _sender; balance : tokens};
  event e
end

(* @dev: Returns the amount of tokens owned by address. *)
transition balanceOf(address: ByStr20)
  optionBal <- balancesMap[address];
  balance = 
    match optionBal with
    | Some bal => bal
    | None => Uint128 0
    end;
  e = {_eventname: "BalanceOfSuccess"; bal: balance};
  event e
end
